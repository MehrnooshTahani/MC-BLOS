#!/usr/bin/env python3
"""
UserRMCatalog_ifVanEckFormat.py

A standalone script that converts a "Van Eck style" rotation measure catalogue
into a "Taylor style" format, with an optional step to merge/average any
overlapping data rows based on positional uncertainty.

USAGE:
    python3 UserRMCatalog_ifVanEckFormat.py [van_eck_file] [optional_output_file] [optional_output_directory] [merge_flag]

    1) van_eck_file (REQUIRED):
       Path to the input Van Eck style catalogue file.

    2) optional_output_file (OPTIONAL):
       Filename or full/relative path to use for the final converted catalogue.
       If not provided, a default name will be generated by appending
       "_(taylor_format).dat" to the base name of the input file.

    3) optional_output_directory (OPTIONAL):
       Directory path in which to place the final converted file.
       - If provided, this overrides any directory portion of optional_output_file.
       - If omitted, and optional_output_file has no directory portion,
         we default to the same directory as the input file.
       - If omitted, but optional_output_file has directory components,
         we respect those.

    4) merge_flag (OPTIONAL: "True" or "False", default="False"):
       If "True", the script will perform a merge step on the input data first,
       combining rows that overlap within their positional errors. The merged
       file overwrites the original input file, and then the Taylor-format
       conversion proceeds on that merged data. If you do not wish to overwrite
       your original file, please back it up or adjust the function accordingly.

EXAMPLE:
    python3 UserRMCatalog_ifVanEckFormat.py my_van_eck_catalog.tsv
        - Produces my_van_eck_catalog_(taylor_format).dat in the same directory,
          no merging step performed.

    python3 UserRMCatalog_ifVanEckFormat.py my_van_eck_catalog.tsv my_output.dat /my/output/dir True
        - Merges overlapping data in 'my_van_eck_catalog.tsv' (overwrites it),
          then converts to Taylor style, saving the final file as:
            /my/output/dir/my_output.dat

    python3 UserRMCatalog_ifVanEckFormat.py my_van_eck_catalog.tsv some/subdir/output.csv
        - No merge. Places the file in "some/subdir/output.csv"
          relative to the current working directory.

IMPORTANT:
    - The input Van Eck style file should contain (at minimum) the following columns:
        ra, dec, pos_err, l, b, stokesI, stokesI_err, polint, polint_err,
        fracpol, fracpol_err, rm, rm_err
    - The merge_close_data_points function overwrites the catalog file passed to it
      with the merged result. If you do not want to overwrite your original file,
      make a copy before running the script with merge_flag set to "True".
    - The script depends on: Python 3.x, pandas, numpy, astropy.

Author:
    John Ming Ngo and Mehrnoosh Tahani, extracted from 00c script with help from ChatGPT for utility purposes.
"""

import sys
import os
import numpy as np
import pandas as pd
from itertools import zip_longest

from astropy.coordinates import Angle
import astropy.units as u


def merge_close_data_points(catalog_file, print_status=True):
    """
    Merges data rows that overlap within their positional errors (pos_err)
    in the specified catalogue file. This function overwrites the file
    given by catalog_file with the merged result.

    Parameters
    ----------
    catalog_file : str
        The path to the Van Eck style catalogue file to be merged in-place.
    print_status : bool, optional
        Whether to print status updates as rows are merged, by default True.

    Returns
    -------
    None
        The merged results are saved (overwriting) to catalog_file.
    """
    data = pd.read_csv(catalog_file, sep='\t', engine="python", on_bad_lines='skip')

    def propagate_error(errors):
        return np.sqrt(np.sum(np.square(errors)))

    def merge_rows(group):
        merged = {}
        for col in data.columns:
            # For numeric columns that are not error columns, default to mean
            if '_err' not in col and col != 'rmsf_fwhm':
                if pd.api.types.is_numeric_dtype(group[col]):
                    if 'min' in col or col.endswith('min'):
                        merged[col] = group[col].min()
                    elif 'max' in col or col.endswith('max') or 'maj' in col:
                        merged[col] = group[col].max()
                    else:
                        merged[col] = group[col].mean()  # Default to mean
                else:
                    # Concatenate strings with a prefix and divider
                    merged[col] = 'Merged:' + '|'.join(group[col].dropna().unique())

        # For error columns and special columns like rmsf_fwhm, propagate
        for col in data.columns:
            if '_err' in col or col == 'rmsf_fwhm':
                merged[col] = propagate_error(group[col])

        return pd.Series(merged)

    merged_rows = []
    while len(data) > 0:
        if print_status and (len(data) % 100 == 0):
            print("Merge Catalogue Close Points, Number of Rows Left:", len(data))

        row = data.iloc[0]
        ra_center = row['ra']
        dec_center = row['dec']
        pos_err = row['pos_err']

        if pd.isna(ra_center) or pd.isna(dec_center) or pd.isna(pos_err):
            close_points = data.loc[[row.name]]
        else:
            close_points = data[
                (data['ra'] >= ra_center - pos_err) & (data['ra'] <= ra_center + pos_err) &
                (data['dec'] >= dec_center - pos_err) & (data['dec'] <= dec_center + pos_err)
            ]

        merged_row = merge_rows(close_points)
        merged_rows.append(merged_row)
        data = data.drop(close_points.index)

    merged_catalog = pd.DataFrame(merged_rows)
    merged_catalog.to_csv(catalog_file, sep='\t', index=False)


def convert_van_eck_to_taylor_format(
    van_eck_file_path: str,
    output_file_path: str,
    merge_data: bool = False
) -> None:
    """
    Reads a Van Eck style catalogue, optionally merges overlapping rows,
    then converts relevant RA/Dec columns into a Taylor-format file.

    Parameters
    ----------
    van_eck_file_path : str
        Path to the Van Eck style input file (e.g., 'consolidated_catalog_ver1.2.0.tsv').
    output_file_path : str
        Desired path for the output (Taylor-format) file. If directories are in this path,
        they must already exist.
    merge_data : bool, optional
        Whether to merge overlapping data points before conversion, by default False.
        WARNING: If True, this will overwrite the input file with the merged result.
                 Back up your input if you need to preserve it unaltered.

    Returns
    -------
    None
        Writes the final Taylor-format file to disk, no return.
    """
    if merge_data:
        print("Merging close data points in the input file before conversion...")
        merge_close_data_points(van_eck_file_path, print_status=True)
        print(f"Merging complete. Overwritten file: {van_eck_file_path}\n")

    print(f"Reading Van Eck catalogue from: {van_eck_file_path}")
    van_eck_data = pd.read_csv(
        van_eck_file_path,
        sep='\t',
        engine="python",
        on_bad_lines='skip'
    )

    # Extract RA/Dec
    ra = van_eck_data['ra']
    dec = van_eck_data['dec']

    # Convert RA/Dec to hms/dms
    ra_hms = Angle(ra, unit='deg').hms
    dec_dms = Angle(dec, unit='deg').dms

    ra_hours, ra_mins, ra_secs = ra_hms.h, ra_hms.m, ra_hms.s
    dec_degs, dec_arcmins, dec_arcsecs = dec_dms.d, np.abs(dec_dms.m), np.abs(dec_dms.s)

    # Convert position error to arcseconds
    err_ang = Angle(van_eck_data['pos_err'], unit='deg')
    ra_err_secs = err_ang.to(u.arcsec).value
    dec_err_arcsecs = err_ang.to(u.arcsec).value

    # Other columns
    longitude_degs = van_eck_data['l']
    latitude_degs = van_eck_data['b']
    nvss_stokes_is = van_eck_data['stokesI']
    stokes_i_errs = van_eck_data['stokesI_err']
    ave_peak_pis = van_eck_data['polint']
    pi_errs = van_eck_data['polint_err']
    polarization_percents = van_eck_data['fracpol']
    m_err_percents = van_eck_data['fracpol_err']
    rotation_measures = van_eck_data['rm']
    rm_errs = van_eck_data['rm_err']

    # Columns in Taylor-format
    taylor_columns = [
        'raHours', 'raMins', 'raSecs', 'raErrSecs',
        'decDegs', 'decArcmins', 'decArcsecs', 'decErrArcsecs',
        'longitudeDegs', 'latitudeDegs',
        'nvssStokesIs', 'stokesIErrs',
        'AvePeakPIs', 'PIErrs',
        'polarizationPercents', 'mErrPercents',
        'rotationMeasures', 'RMErrs'
    ]

    # Build the data
    taylor_data = list(zip_longest(
        ra_hours, ra_mins, ra_secs, ra_err_secs,
        dec_degs, dec_arcmins, dec_arcsecs, dec_err_arcsecs,
        longitude_degs, latitude_degs,
        nvss_stokes_is, stokes_i_errs,
        ave_peak_pis, pi_errs,
        polarization_percents, m_err_percents,
        rotation_measures, rm_errs,
        fillvalue=''
    ))

    van_eck_to_taylor_frame = pd.DataFrame(taylor_data, columns=taylor_columns)

    print(f"Saving the converted Taylor-style catalogue to: {output_file_path}")
    # Validate that directory exists
    out_dir = os.path.dirname(os.path.abspath(output_file_path))
    if out_dir and not os.path.isdir(out_dir):
        raise OSError(f"Cannot save file into a non-existent directory: '{out_dir}'")

    van_eck_to_taylor_frame.to_csv(
        output_file_path,
        sep='\t',
        na_rep='nan',
        index=False
    )

    print("\nConversion complete.")
    print("Please verify the new file to ensure the data are as expected.\n")


def main():
    """
    Main command-line entry point. Parses arguments and calls the conversion.

    Usage:
      python3 UserRMCatalog_ifVanEckFormat.py [van_eck_file] [optional_output_file] [optional_output_directory] [merge_flag]

    See script docstring at the top for details.
    """
    args = sys.argv[1:]

    if len(args) < 1:
        print("\nError: No Van Eck_type catalogue file provided.\n")
        print("Usage:\n  python3 UserRMCatalog_ifVanEckFormat.py [van_eck_file] "
              "[optional_output_file] [optional_output_directory] [merge_flag]\n")
        sys.exit(1)

    # 1) Required input file
    van_eck_file_path = args[0]
    base_input_name, ext_input = os.path.splitext(os.path.basename(van_eck_file_path))
    default_out_name = f"{base_input_name}_(taylor_format).dat"
    default_out_dir = os.path.dirname(os.path.abspath(van_eck_file_path))

    # 2) optional_output_file (could be a full path or just a filename)
    output_filename = None
    output_directory = None
    merge_data = False

    # We'll track which arguments are left to interpret for merge
    leftover_args = []

    if len(args) > 1 and args[1].lower() not in ["true", "false"]:
        # The user gave some path or filename
        second_arg_path = os.path.abspath(args[1])
        # Split into directory + basename
        second_arg_dir = os.path.dirname(second_arg_path)
        second_arg_base = os.path.basename(second_arg_path)

        # We'll store these, but the user might also provide a third param as directory
        output_filename = second_arg_base  # e.g. "Test2.csv"
        # If the second_arg_dir is not just ".", it's a real directory path the user gave
        # We won't finalize it yet. The user might override with the third param
        # or if the user provided no third param, we use second_arg_dir
        if second_arg_dir not in ["", ".", None]:
            output_directory = second_arg_dir

        # This argument is "consumed"
        leftover_args = args[2:]
    else:
        # Not provided OR the second arg is "true"/"false" => use defaults
        output_filename = default_out_name
        leftover_args = args[1:]

    # 3) optional_output_directory (if the next leftover arg is not "true"/"false", treat it as directory)
    if leftover_args and leftover_args[0].lower() not in ["true", "false"]:
        # This is an explicit directory
        output_directory = os.path.abspath(leftover_args[0])
        leftover_args = leftover_args[1:]
    else:
        # If we had no directory from the second_arg or second_arg_dir was just "."
        if not output_directory:
            output_directory = default_out_dir

    # 4) merge_flag (any leftover arg that is 'true' => True, 'false' => False)
    for possible_flag in leftover_args:
        if possible_flag.strip().lower() == "true":
            merge_data = True
            break
        elif possible_flag.strip().lower() == "false":
            merge_data = False
            break

    # Construct final path
    output_file_path = os.path.join(output_directory, output_filename)

    convert_van_eck_to_taylor_format(
        van_eck_file_path=van_eck_file_path,
        output_file_path=output_file_path,
        merge_data=merge_data
    )


if __name__ == "__main__":
    main()
